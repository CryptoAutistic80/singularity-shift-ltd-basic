<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="google-site-verification" content="eBAql9spKB7y_X3uwIII0DfCVOcUJo66UwR414YUMYY" />
  <title>Singularity Shift Ltd</title>
  <link rel="icon" type="image/x-icon" href="assets/favicon.ico" />
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link
    href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:wght@400;500&family=Inter:wght@400;500;600&family=Inter+Tight:wght@600;700&display=swap"
    rel="stylesheet" />
  <style>
    :root {
      color-scheme: dark;
      --bg-deep: #0a0f1a;
      --bg-surface: #111827;
      --bg-elevated: #1a2332;
      --ink: #e8edf5;
      --ink-soft: #a0aec0;
      --ink-muted: #6b7a8f;
      --accent: #4a6fa5;
      --accent-soft: #6b8cba;
      --glow-primary: #7a9bb8;
      --glow-secondary: #a0b8cc;
      --glass-border: rgba(122, 155, 184, 0.15);
      --glass-bg: rgba(17, 24, 39, 0.7);
      --glass-highlight: rgba(160, 184, 204, 0.08);
      --radius-lg: 30px;
      --radius-md: 22px;
      --font-display: "Inter Tight", "Inter", system-ui, -apple-system, "Segoe UI", sans-serif;
      --font-body: "Inter", system-ui, -apple-system, "Segoe UI", sans-serif;
      --font-mono: "IBM Plex Mono", "Roboto Mono", ui-monospace, SFMono-Regular, monospace;
      --space-1: 4px;
      --space-2: 8px;
      --space-3: 12px;
      --space-4: 16px;
      --space-5: 24px;
      --space-6: 32px;
      --space-7: 48px;
      --space-8: 64px;
      --space-9: 96px;
      --section-pad: clamp(56px, 8vw, 88px);
      --container: min(1100px, calc(100% - 72px));
    }

    * {
      box-sizing: border-box;
    }

    html {
      scroll-behavior: smooth;
    }

    body {
      margin: 0;
      font-family: var(--font-body);
      font-size: 18px;
      line-height: 1.6;
      color: var(--ink);
      background: var(--bg-deep);
      min-height: 100vh;
      position: relative;
      overflow-x: hidden;
      overflow-y: auto;
    }

    #penteract-canvas {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 0;
      pointer-events: none;
    }

    .page {
      position: relative;
      z-index: 1;
    }

    .parallax-section {
      min-height: 82vh;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      padding: var(--section-pad) 0;
      position: relative;
    }

    .parallax-section.hero-section {
      min-height: 95vh;
      padding-top: calc(var(--section-pad) + 64px);
    }

    .parallax-section.footer-section {
      min-height: 46vh;
      justify-content: center;
    }

    /* Parallax layer system */
    .parallax-layer {
      will-change: transform;
      transition: transform 0.1s linear;
    }

    .parallax-content {
      position: relative;
      z-index: 2;
    }

    /* Floating elements that move at different rates */
    .parallax-float {
      position: absolute;
      border-radius: 50%;
      background: radial-gradient(circle, rgba(122, 155, 184, 0.15) 0%, transparent 70%);
      pointer-events: none;
      will-change: transform;
    }

    .float-1 {
      width: 300px;
      height: 300px;
      top: 10%;
      left: -5%;
      opacity: 0.4;
    }

    .float-2 {
      width: 200px;
      height: 200px;
      top: 60%;
      right: -3%;
      opacity: 0.3;
    }

    .float-3 {
      width: 150px;
      height: 150px;
      top: 30%;
      right: 10%;
      opacity: 0.25;
    }

    a {
      color: var(--accent-soft);
      font-weight: 600;
      text-decoration: none;
      transition: color 0.24s ease, text-shadow 0.24s ease;
    }

    a:hover,
    a:focus-visible {
      color: var(--glow-secondary);
      text-shadow: 0 0 20px rgba(160, 184, 204, 0.4);
    }

    a:focus-visible {
      outline: 2px solid rgba(122, 155, 184, 0.4);
      outline-offset: 3px;
    }

    .site-header {
      position: fixed;
      top: clamp(18px, 4vw, 32px);
      left: 50%;
      transform: translateX(-50%) translateY(0);
      width: var(--container);
      max-width: 1100px;
      border-radius: 999px;
      background: rgba(17, 24, 39, 0.85);
      backdrop-filter: blur(20px);
      -webkit-backdrop-filter: blur(20px);
      border: 1px solid var(--glass-border);
      box-shadow:
        0 0 1px rgba(160, 184, 204, 0.3),
        0 18px 45px -30px rgba(0, 0, 0, 0.8),
        inset 0 1px 0 rgba(160, 184, 204, 0.1);
      padding: var(--space-2) var(--space-4);
      z-index: 100;
      transition: transform 0.4s cubic-bezier(0.16, 1, 0.3, 1),
                  background 0.3s ease,
                  box-shadow 0.3s ease;
    }

    .site-header.scrolled {
      background: rgba(17, 24, 39, 0.95);
      box-shadow:
        0 0 1px rgba(160, 184, 204, 0.4),
        0 8px 32px -8px rgba(0, 0, 0, 0.6),
        inset 0 1px 0 rgba(160, 184, 204, 0.15);
    }

    .site-header.hidden {
      transform: translateX(-50%) translateY(-120%);
    }

    .nav {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: var(--space-4);
    }

    .brand {
      font-family: var(--font-display);
      font-size: 18px;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 0.16em;
      color: var(--ink);
      text-shadow: 0 0 30px rgba(160, 184, 204, 0.2);
    }

    .nav-cta {
      position: relative;
      display: inline-flex;
      align-items: center;
      gap: var(--space-2);
      padding: 10px 22px;
      border-radius: 999px;
      border: 1px solid rgba(122, 155, 184, 0.3);
      color: var(--ink);
      background: linear-gradient(135deg, rgba(74, 111, 165, 0.3), rgba(107, 140, 186, 0.2));
      box-shadow:
        0 0 20px rgba(122, 155, 184, 0.15),
        inset 0 1px 0 rgba(160, 184, 204, 0.2);
      transition: transform 0.25s ease, box-shadow 0.25s ease, border-color 0.25s ease;
    }

    .nav-cta:hover,
    .nav-cta:focus-visible {
      transform: translateY(-2px);
      border-color: rgba(160, 184, 204, 0.5);
      box-shadow:
        0 0 30px rgba(122, 155, 184, 0.25),
        0 22px 46px -30px rgba(0, 0, 0, 0.8),
        inset 0 1px 0 rgba(160, 184, 204, 0.3);
      color: var(--ink);
    }

    main {
      display: contents;
    }

    /* Micro parallax helper: slight skew + z-index bump on hover */
    .parallax-layer {
      transform-origin: center;
      transition: transform 0.4s cubic-bezier(0.16, 1, 0.3, 1),
                  box-shadow 0.4s ease;
      will-change: transform;
    }

    .panel.parallax-layer:hover {
      transform: translateY(-6px) rotateX(1deg) rotateY(-1deg);
      box-shadow:
        0 22px 48px -32px rgba(0, 0, 0, 0.9),
        inset 0 1px 0 rgba(160, 184, 204, 0.12);
    }

    .panel {
      position: relative;
      width: var(--container);
      max-width: 1100px;
      padding: clamp(3.2rem, 6vw, 5rem);
      border-radius: var(--radius-lg);
      border: 1px solid var(--glass-border);
      background: var(--glass-bg);
      backdrop-filter: blur(20px);
      -webkit-backdrop-filter: blur(20px);
      box-shadow:
        0 0 1px rgba(160, 184, 204, 0.2),
        0 34px 60px -44px rgba(0, 0, 0, 0.9),
        inset 0 1px 0 var(--glass-highlight);
      overflow: hidden;
      isolation: isolate;
      opacity: 0;
      transform: translateY(60px) scale(0.98);
      transition: opacity 0.8s cubic-bezier(0.16, 1, 0.3, 1),
                  transform 0.8s cubic-bezier(0.16, 1, 0.3, 1);
    }

    .panel.visible {
      opacity: 1;
      transform: translateY(0) scale(1);
    }

    /* Staggered reveal for panel children */
    .panel.visible .meta-label,
    .panel.visible h1,
    .panel.visible h2,
    .panel.visible .lede,
    .panel.visible p,
    .panel.visible .hero-visual,
    .panel.visible .about-grid,
    .panel.visible .capability-flow,
    .panel.visible .tool-wall,
    .panel.visible .annotation-card {
      opacity: 0;
      animation: revealUp 0.6s cubic-bezier(0.16, 1, 0.3, 1) forwards;
    }

    .panel.visible .meta-label { animation-delay: 0.1s; }
    .panel.visible h1, .panel.visible h2 { animation-delay: 0.2s; }
    .panel.visible .lede { animation-delay: 0.3s; }
    .panel.visible p { animation-delay: 0.35s; }
    .panel.visible .hero-visual { animation-delay: 0.25s; }
    .panel.visible .about-grid { animation-delay: 0.2s; }
    .panel.visible .annotation-card { animation-delay: 0.4s; }
    .panel.visible .capability-flow { animation-delay: 0.3s; }
    .panel.visible .tool-wall { animation-delay: 0.3s; }

    @keyframes revealUp {
      from {
        opacity: 0;
        transform: translateY(20px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    /* Staggered capability nodes */
    .panel.visible .capability-node {
      opacity: 0;
      animation: revealUp 0.5s cubic-bezier(0.16, 1, 0.3, 1) forwards;
    }

    .panel.visible .capability-node:nth-child(1) { animation-delay: 0.35s; }
    .panel.visible .capability-node:nth-child(2) { animation-delay: 0.45s; }
    .panel.visible .capability-node:nth-child(3) { animation-delay: 0.55s; }
    .panel.visible .capability-node:nth-child(4) { animation-delay: 0.65s; }
    .panel.visible .capability-node:nth-child(5) { animation-delay: 0.75s; }

    /* Staggered tool pills */
    .panel.visible .tool-pill {
      opacity: 0;
      animation: revealUp 0.4s cubic-bezier(0.16, 1, 0.3, 1) forwards;
    }

    .panel.visible .tool-pill:nth-child(1) { animation-delay: 0.35s; }
    .panel.visible .tool-pill:nth-child(2) { animation-delay: 0.4s; }
    .panel.visible .tool-pill:nth-child(3) { animation-delay: 0.45s; }
    .panel.visible .tool-pill:nth-child(4) { animation-delay: 0.5s; }
    .panel.visible .tool-pill:nth-child(5) { animation-delay: 0.55s; }
    .panel.visible .tool-pill:nth-child(6) { animation-delay: 0.6s; }
    .panel.visible .tool-pill:nth-child(7) { animation-delay: 0.65s; }
    .panel.visible .tool-pill:nth-child(8) { animation-delay: 0.7s; }
    .panel.visible .tool-pill:nth-child(9) { animation-delay: 0.75s; }
    .panel.visible .tool-pill:nth-child(10) { animation-delay: 0.8s; }

    .panel::before {
      content: "";
      position: absolute;
      inset: 0;
      border-radius: inherit;
      background: radial-gradient(ellipse at 50% 0%, rgba(122, 155, 184, 0.08) 0%, transparent 60%);
      pointer-events: none;
    }

    .panel>* {
      position: relative;
      z-index: 1;
    }

    .meta-label {
      display: inline-block;
      font-family: var(--font-mono);
      font-size: 12px;
      letter-spacing: 0.18em;
      text-transform: uppercase;
      color: var(--accent-soft);
      margin-bottom: var(--space-3);
      text-shadow: 0 0 20px rgba(107, 140, 186, 0.4);
    }

    .hero {
      display: grid;
      grid-template-columns: minmax(0, 1.05fr) minmax(0, 0.95fr);
      gap: clamp(2rem, 6vw, 4rem);
    }

    h1 {
      margin: var(--space-4) 0 var(--space-4);
      font-family: var(--font-display);
      font-size: clamp(2.5rem, 3.6vw + 1.5rem, 3.5rem);
      line-height: 1.1;
      letter-spacing: 0.03em;
      max-width: 20ch;
      background: linear-gradient(135deg, var(--ink) 0%, var(--glow-secondary) 100%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    .lede {
      max-width: 48ch;
      color: var(--ink-soft);
    }

    .hero-copy {
      display: flex;
      flex-direction: column;
      gap: var(--space-4);
    }

    .hero-copy p {
      margin: 0;
    }

    .primary-cta {
      display: inline-flex;
      align-items: center;
      gap: var(--space-2);
      align-self: flex-start;
      padding: 12px 26px;
      border-radius: 999px;
      background: rgba(26, 35, 50, 0.6);
      color: var(--ink);
      border: 1px solid rgba(122, 155, 184, 0.25);
      box-shadow:
        0 0 20px rgba(122, 155, 184, 0.1),
        inset 0 1px 0 rgba(160, 184, 204, 0.15);
      font-weight: 600;
      transition: transform 0.25s ease, box-shadow 0.25s ease, border-color 0.25s ease;
      position: relative;
      overflow: hidden;
    }

    .primary-cta:hover,
    .primary-cta:focus-visible {
      color: var(--glow-secondary);
      transform: translateY(-2px);
      border-color: rgba(160, 184, 204, 0.4);
      box-shadow:
        0 0 30px rgba(122, 155, 184, 0.2),
        0 22px 44px -32px rgba(0, 0, 0, 0.8),
        inset 0 1px 0 rgba(160, 184, 204, 0.25);
    }

    .hero-visual {
      align-self: center;
      justify-self: center;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: var(--space-3);
      padding: var(--space-5);
      border-radius: calc(var(--radius-lg) - 10px);
      border: 1px solid rgba(122, 155, 184, 0.2);
      background: rgba(17, 24, 39, 0.5);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      box-shadow:
        0 0 40px rgba(122, 155, 184, 0.1),
        inset 0 1px 0 rgba(160, 184, 204, 0.1);
      position: relative;
      overflow: hidden;
    }

    .hero-visual::before {
      content: "";
      position: absolute;
      inset: -50%;
      background: radial-gradient(circle at center, rgba(122, 155, 184, 0.15) 0%, transparent 50%);
      animation: pulse-glow 4s ease-in-out infinite;
    }

    .hero-visual img {
      position: relative;
      z-index: 1;
      display: block;
      width: min(100%, 330px);
      height: auto;
      border-radius: calc(var(--radius-lg) - 20px);
      filter: drop-shadow(0 0 30px rgba(122, 155, 184, 0.3));
    }

    h2 {
      margin: var(--space-4) 0 var(--space-4);
      font-family: var(--font-display);
      font-size: clamp(1.9rem, 2vw + 1.4rem, 2.4rem);
      letter-spacing: 0.03em;
      color: var(--ink);
    }

    h3 {
      margin: 0 0 var(--space-2);
      font-family: var(--font-display);
      font-weight: 600;
      font-size: 1.2rem;
      letter-spacing: 0.02em;
      color: var(--ink);
    }

    p {
      margin: 0 0 var(--space-4);
      color: var(--ink-soft);
    }

    .section-note {
      margin-bottom: var(--space-5);
      max-width: 54ch;
    }

    .about-grid {
      display: grid;
      gap: var(--space-6);
      grid-template-columns: minmax(0, 1.1fr) minmax(0, 0.9fr);
      align-items: start;
    }

    .annotation-card {
      position: relative;
      padding: var(--space-5);
      border-radius: var(--radius-md);
      border: 1px solid rgba(122, 155, 184, 0.2);
      background: rgba(26, 35, 50, 0.6);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      box-shadow:
        0 0 30px rgba(122, 155, 184, 0.08),
        inset 0 1px 0 rgba(160, 184, 204, 0.1);
    }

    .annotation-card::before {
      content: "";
      position: absolute;
      inset: var(--space-2);
      border-radius: calc(var(--radius-md) - var(--space-2));
      background:
        repeating-linear-gradient(90deg, rgba(122, 155, 184, 0.04) 0, rgba(122, 155, 184, 0.04) 1px, transparent 1px, transparent 20px),
        repeating-linear-gradient(180deg, rgba(122, 155, 184, 0.03) 0, rgba(122, 155, 184, 0.03) 1px, transparent 1px, transparent 20px);
      opacity: 0.6;
      pointer-events: none;
    }

    .annotation-header {
      font-family: var(--font-mono);
      font-size: 14px;
      letter-spacing: 0.12em;
      text-transform: uppercase;
      color: var(--accent-soft);
      margin-bottom: var(--space-3);
      text-shadow: 0 0 15px rgba(107, 140, 186, 0.3);
    }

    .annotation-footnote {
      margin-top: var(--space-4);
      font-family: var(--font-mono);
      font-size: 13px;
      letter-spacing: 0.1em;
      text-transform: uppercase;
      color: var(--ink-muted);
    }

    .capability-flow {
      display: grid;
      gap: var(--space-4);
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
    }

    .capability-node {
      position: relative;
      display: flex;
      flex-direction: column;
      gap: var(--space-3);
      padding: var(--space-5) var(--space-4);
      border-radius: 24px;
      border: 1px solid rgba(122, 155, 184, 0.15);
      background: rgba(26, 35, 50, 0.5);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      box-shadow:
        inset 0 1px 0 rgba(160, 184, 204, 0.08),
        0 22px 40px -32px rgba(0, 0, 0, 0.7);
      transition: transform 0.25s ease, box-shadow 0.25s ease, border-color 0.25s ease;
    }

    .capability-node:hover {
      transform: translateY(-6px);
      border-color: rgba(160, 184, 204, 0.3);
      box-shadow:
        0 0 40px rgba(122, 155, 184, 0.15),
        inset 0 1px 0 rgba(160, 184, 204, 0.15),
        0 28px 48px -30px rgba(0, 0, 0, 0.8);
    }

    .capability-node h3 {
      font-size: 1.05rem;
      letter-spacing: 0.02em;
      margin: 0;
    }

    .capability-node p {
      margin: 0;
      font-size: 0.97rem;
      line-height: 1.6;
      color: var(--ink-soft);
    }

    .tool-wall {
      display: grid;
      gap: var(--space-3);
      grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
    }

    .tool-pill {
      position: relative;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: var(--space-1);
      padding: 12px 20px;
      border-radius: 999px;
      border: 1px solid rgba(122, 155, 184, 0.2);
      background: rgba(26, 35, 50, 0.6);
      color: var(--ink);
      font-weight: 500;
      font-size: 0.95rem;
      box-shadow:
        0 0 20px rgba(122, 155, 184, 0.08),
        inset 0 1px 0 rgba(160, 184, 204, 0.1);
      transition: transform 0.25s ease, box-shadow 0.25s ease, border-color 0.25s ease;
      overflow: hidden;
    }

    .tool-pill::before {
      content: "";
      position: absolute;
      inset: -1px;
      border-radius: inherit;
      background: linear-gradient(120deg, transparent, rgba(160, 184, 204, 0.15), transparent);
      opacity: 0;
      animation: shimmer 6s linear infinite;
      pointer-events: none;
    }

    .tool-pill:hover {
      transform: translateY(-2px);
      border-color: rgba(160, 184, 204, 0.35);
      box-shadow:
        0 0 30px rgba(122, 155, 184, 0.15),
        0 22px 46px -30px rgba(0, 0, 0, 0.7);
    }

    .tool-pill:hover::before {
      opacity: 1;
    }

    .tool-pill span {
      font-family: var(--font-mono);
      font-size: 12px;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      color: var(--ink-muted);
    }

    .site-footer {
      position: relative;
      width: var(--container);
      max-width: 1100px;
      border-radius: var(--radius-md);
      padding: var(--space-6) var(--space-5);
      background: rgba(17, 24, 39, 0.8);
      backdrop-filter: blur(20px);
      -webkit-backdrop-filter: blur(20px);
      border: 1px solid var(--glass-border);
      color: var(--ink-soft);
      text-align: center;
      box-shadow:
        0 0 1px rgba(160, 184, 204, 0.2),
        0 28px 60px -36px rgba(0, 0, 0, 0.9),
        inset 0 1px 0 var(--glass-highlight);
      overflow: hidden;
    }

    .site-footer::before {
      content: "";
      position: absolute;
      top: var(--space-4);
      left: 50%;
      width: 8px;
      height: 8px;
      border-radius: 999px;
      background: var(--glow-primary);
      box-shadow: 0 0 20px var(--glow-primary), 0 0 40px rgba(122, 155, 184, 0.4);
      transform: translateX(-50%);
      animation: heartbeat 1.6s ease-in-out infinite alternate;
    }

    .site-footer::after {
      content: "";
      position: absolute;
      top: calc(var(--space-4) + 18px);
      left: 12%;
      right: 12%;
      height: 1px;
      background: linear-gradient(90deg, transparent, rgba(122, 155, 184, 0.4), transparent);
      opacity: 0.6;
    }

    .site-footer p {
      margin: var(--space-3) 0 0;
      font-size: 15px;
    }

    .site-footer a {
      color: var(--glow-primary);
    }

    @keyframes shimmer {
      0% {
        transform: translateX(-100%);
      }
      100% {
        transform: translateX(100%);
      }
    }

    @keyframes heartbeat {
      0% {
        opacity: 0.6;
        transform: translateX(-50%) scale(0.85);
      }
      100% {
        opacity: 1;
        transform: translateX(-50%) scale(1.1);
      }
    }

    @keyframes pulse-glow {
      0%, 100% {
        opacity: 0.5;
        transform: scale(1);
      }
      50% {
        opacity: 0.8;
        transform: scale(1.1);
      }
    }

    @media (min-width: 900px) {
      .capability-flow {
        gap: var(--space-5);
      }
    }

    @media (max-width: 960px) {
      :root {
        --container: min(1100px, calc(100% - 48px));
        --section-pad: clamp(48px, 10vw, 72px);
      }

      body {
        font-size: 17px;
      }

      .hero {
        grid-template-columns: 1fr;
      }

      .about-grid {
        grid-template-columns: 1fr;
      }
    }

    @media (max-width: 720px) {
      :root {
        --container: min(1100px, calc(100% - 32px));
        --section-pad: clamp(40px, 12vw, 64px);
      }

      body {
        font-size: 16px;
      }

      .site-header {
        padding: var(--space-2) var(--space-3);
      }

      .panel {
        padding: var(--space-6) var(--space-4);
      }

      .parallax-section {
        min-height: auto;
        padding: var(--section-pad) 0;
      }

      .parallax-section.hero-section {
        min-height: 100vh;
      }

      h1 {
        font-size: clamp(2.4rem, 7vw + 1.4rem, 3rem);
      }

      .hero-copy {
        gap: var(--space-3);
      }

      .hero-visual {
        padding: var(--space-4);
      }

      .tool-wall {
        grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
      }

      .parallax-float {
        display: none;
      }
    }

    /* Scroll indicator for hero */
    .scroll-indicator {
      position: absolute;
      bottom: var(--space-7);
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: var(--space-2);
      color: var(--ink-muted);
      font-family: var(--font-mono);
      font-size: 11px;
      letter-spacing: 0.15em;
      text-transform: uppercase;
      opacity: 0;
      transition: opacity 0.6s ease;
    }

    .scroll-indicator.visible {
      opacity: 0.7;
      animation: bounce 2s ease-in-out infinite;
    }

    .scroll-indicator::after {
      content: '';
      width: 1px;
      height: 40px;
      background: linear-gradient(to bottom, var(--ink-muted), transparent);
    }

    @keyframes bounce {
      0%, 100% { transform: translateX(-50%) translateY(0); }
      50% { transform: translateX(-50%) translateY(10px); }
    }

    @media (max-width: 720px) {
      .scroll-indicator {
        bottom: var(--space-5);
      }
    }

    @media (prefers-reduced-motion: reduce) {
      *,
      *::before,
      *::after {
        animation-duration: 0.001ms !important;
        animation-iteration-count: 1 !important;
        transition-duration: 0.001ms !important;
        scroll-behavior: auto !important;
      }

      #penteract-canvas {
        display: none;
      }

      .panel {
        opacity: 1;
        transform: none;
      }

      .parallax-layer {
        transform: none !important;
      }

      .parallax-float {
        display: none;
      }

      .panel.visible .meta-label,
      .panel.visible h1,
      .panel.visible h2,
      .panel.visible .lede,
      .panel.visible p,
      .panel.visible .hero-visual,
      .panel.visible .about-grid,
      .panel.visible .capability-flow,
      .panel.visible .tool-wall,
      .panel.visible .annotation-card,
      .panel.visible .capability-node,
      .panel.visible .tool-pill {
        opacity: 1;
        animation: none;
      }
    }
  </style>
</head>

<body>
  <canvas id="penteract-canvas"></canvas>

  <header class="site-header" id="site-header">
    <nav class="nav" aria-label="Primary">
      <span class="brand">Singularity Shift</span>
      <a class="nav-cta" href="mailto:singularityshiftai@gmail.com">Email us</a>
    </nav>
  </header>

  <div class="page">
    <main>
      <div class="parallax-section hero-section" data-speed="0.3">
        <div class="parallax-float float-1" data-speed="0.1"></div>
        <div class="parallax-float float-2" data-speed="0.15"></div>
        <section class="hero panel parallax-layer" aria-labelledby="hero-title" data-speed="0.5">
          <div class="hero-copy">
            <span class="meta-label">Overview</span>
            <h1 id="hero-title">We build systems that think — clearly.</h1>
            <p class="lede">Practical engineering, clean architecture, measurable outcomes.</p>
            <p>
              Singularity Shift ships end-to-end platforms where agentic AI, resilient services, and thoughtful interfaces
              work as one system.
              Every engagement favours maintainable velocity, crisp documentation, and measurable outcomes over theatrical
              launches.
            </p>
          </div>
          <figure class="hero-visual">
            <img src="assets/logo_clean_white.png" alt="Precision layers sketched before a single commit."
              loading="lazy" />
          </figure>
        </section>
        <div class="scroll-indicator">Scroll</div>
      </div>

      <div class="parallax-section" data-speed="0.4">
        <div class="parallax-float float-3" data-speed="0.08"></div>
        <section class="panel parallax-layer" aria-labelledby="about-title" data-speed="0.6">
          <div class="about-grid">
            <div>
              <span class="meta-label">About</span>
              <h2 id="about-title">Designing clarity since 2023</h2>
              <p>
                We design, build, and ship practical software—clean architectures, calm infrastructure, and interfaces
                that make decisions legible.
                The work blends technical illustration with disciplined engineering so complex systems feel grounded.
              </p>
              <p>
                Based in Cheltenham, we embed with founders and product teams to translate ambiguous ideas into reliable
                platforms.
                Expect measured releases, accountable communication, and artefacts you can revisit months later.
              </p>
            </div>
            <aside class="annotation-card" aria-label="Founder's annotation">
              <div class="annotation-header">Founder field note →</div>
              <p>
                James is a self-taught systems engineer who treats every project like a technical field report—diagrammed,
                annotated, and shipped with operational guidance.
                Agentic workflows, backend services, and interface craft are handled as one conversation.
              </p>
              <p class="annotation-footnote">Hands-on from exploration through ship-ready runbooks.</p>
            </aside>
          </div>
        </section>
      </div>

      <div class="parallax-section" data-speed="0.45">
        <div class="parallax-float float-1" data-speed="0.12"></div>
        <section class="panel parallax-layer" aria-labelledby="capabilities-title" data-speed="0.65">
          <span class="meta-label">Architecture focus</span>
          <h2 id="capabilities-title">A connected diagram from blueprint through handover.</h2>
          <p class="section-note">
            Each capability is a node in the same system—we build bridges, not silos. The line stays unbroken from ingress
            to insights, operations to documentation.
          </p>
          <div class="capability-flow" role="list">
            <article class="capability-node" role="listitem">
              <h3>Backend systems</h3>
              <p>Resilient APIs, event pipelines, and background workers with observability, alerts, and rollback paths.
              </p>
            </article>
            <article class="capability-node" role="listitem">
              <h3>Front-end clarity</h3>
              <p>Interfaces that surface the right decision at the right time—accessible, responsive, and grounded in
                data.</p>
            </article>
            <article class="capability-node" role="listitem">
              <h3>Data orchestration</h3>
              <p>Structured storage, reporting layers, and evaluation harnesses so AI workflows stay measurable.</p>
            </article>
            <article class="capability-node" role="listitem">
              <h3>Infrastructure craft</h3>
              <p>Calm deployments with containers, IaC, and pragmatic automation—documented for long-term stewardship.</p>
            </article>
            <article class="capability-node" role="listitem">
              <h3>Runbooks &amp; docs</h3>
              <p>Diagrammed architecture notes, operations checklists, and field guides that future teams can trust.</p>
            </article>
          </div>
        </section>
      </div>

      <div class="parallax-section" data-speed="0.5">
        <div class="parallax-float float-2" data-speed="0.1"></div>
        <section class="panel parallax-layer" aria-labelledby="tools-title" data-speed="0.7">
          <span class="meta-label">System tools</span>
          <h2 id="tools-title">Languages and tooling we reach for often.</h2>
          <p class="section-note">
            Calm, proven stacks with thoughtful defaults. We mix disciplined engineering with creative exploration, always
            leaving a trail for the next maintainer.
          </p>
          <div class="tool-wall">
            <span class="tool-pill"><span>Core</span>TypeScript</span>
            <span class="tool-pill"><span>Core</span>Python</span>
            <span class="tool-pill"><span>Runtime</span>Node.js</span>
            <span class="tool-pill"><span>Runtime</span>Rust</span>
            <span class="tool-pill"><span>Data</span>PostgreSQL</span>
            <span class="tool-pill"><span>Data</span>SQLite</span>
            <span class="tool-pill"><span>Infra</span>Docker</span>
            <span class="tool-pill"><span>Infra</span>GitHub Actions</span>
            <span class="tool-pill"><span>Ops</span>Grafana &amp; OpenTelemetry</span>
            <span class="tool-pill"><span>Front-end</span>React &amp; Next.js</span>
          </div>
        </section>
      </div>

      <div class="parallax-section footer-section" data-speed="0.55">
        <footer class="site-footer parallax-layer" data-speed="0.75">
          <p>© 2025 Singularity Shift Ltd · Cheltenham, UK · <a href="mailto:singularityshiftai@gmail.com">Email us</a></p>
        </footer>
      </div>
    </main>
  </div>

  <script>
    // Smooth Parallax System
    (function() {
      'use strict';

      const prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;
      if (prefersReducedMotion) {
        // Still show panels without animation
        document.querySelectorAll('.panel').forEach(p => p.classList.add('visible'));
        return;
      }

      // Smooth scroll tracking
      let currentScroll = 0;
      let targetScroll = 0;
      let rafId = null;
      const smoothness = 0.08;

      // Elements
      const header = document.querySelector('.site-header');
      const scrollIndicator = document.querySelector('.scroll-indicator');
      const panels = document.querySelectorAll('.panel');
      const parallaxLayers = document.querySelectorAll('[data-speed]');
      const floats = document.querySelectorAll('.parallax-float');

      let lastScroll = 0;
      let scrollDirection = 'down';
      let headerHidden = false;

      // Show scroll indicator after a delay
      setTimeout(() => {
        if (scrollIndicator) scrollIndicator.classList.add('visible');
      }, 1500);

      // Intersection Observer for panel reveals
      const revealObserver = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
          if (entry.isIntersecting) {
            entry.target.classList.add('visible');
          }
        });
      }, {
        rootMargin: '-5% 0px -5% 0px',
        threshold: 0.15
      });

      panels.forEach(panel => revealObserver.observe(panel));

      // Parallax update function with subtle skew
      function updateParallax() {
        currentScroll += (targetScroll - currentScroll) * smoothness;

        parallaxLayers.forEach(layer => {
          const speed = parseFloat(layer.dataset.speed) || 0.5;
          const rect = layer.getBoundingClientRect();
          const centerY = rect.top + rect.height / 2;
          const viewportCenter = window.innerHeight / 2;
          const offset = (centerY - viewportCenter) * (1 - speed) * 0.28;
          const tilt = (centerY - viewportCenter) * 0.00012;

          layer.style.transform = `translateY(${offset}px) rotateX(${tilt}rad) rotateY(${tilt * -0.6}rad)`;
        });

        floats.forEach(float => {
          const speed = parseFloat(float.dataset.speed) || 0.1;
          const offset = currentScroll * speed * 0.5;
          float.style.transform = `translateY(${-offset}px)`;
        });

        // Header hide/show on scroll direction
        if (Math.abs(targetScroll - lastScroll) > 5) {
          scrollDirection = targetScroll > lastScroll ? 'down' : 'up';
          lastScroll = targetScroll;

          if (targetScroll > 100) {
            if (scrollDirection === 'down' && !headerHidden) {
              header.classList.add('hidden');
              headerHidden = true;
            } else if (scrollDirection === 'up' && headerHidden) {
              header.classList.remove('hidden');
              headerHidden = false;
            }
            header.classList.add('scrolled');
          } else {
            header.classList.remove('hidden', 'scrolled');
            headerHidden = false;
          }
        }

        // Hide scroll indicator
        if (targetScroll > 80 && scrollIndicator) {
          scrollIndicator.classList.remove('visible');
        }

        // Continue animation loop
        if (Math.abs(targetScroll - currentScroll) > 0.5) {
          rafId = requestAnimationFrame(updateParallax);
        } else {
          rafId = null;
        }
      }

      // Scroll event listener
      window.addEventListener('scroll', () => {
        targetScroll = window.pageYOffset || document.documentElement.scrollTop;

        if (!rafId) {
          rafId = requestAnimationFrame(updateParallax);
        }
      }, { passive: true });

      // Initial state
      targetScroll = window.pageYOffset || document.documentElement.scrollTop;
      currentScroll = targetScroll;

      // Trigger initial parallax calculation
      requestAnimationFrame(updateParallax);

      // Show first panel immediately
      if (panels.length > 0) {
        setTimeout(() => panels[0].classList.add('visible'), 100);
      }
    })();
  </script>

  <script>
    (function() {
      'use strict';

      const canvas = document.getElementById('penteract-canvas');
      if (!canvas) return;
      const ctx = canvas.getContext('2d', { alpha: false });

      const prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;
      const cssBg = getComputedStyle(document.documentElement).getPropertyValue('--bg-deep').trim();
      const BACKDROP = cssBg || '#030308';

      if (prefersReducedMotion) {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        ctx.fillStyle = BACKDROP;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        return;
      }

      const COLORS = {
        void: BACKDROP,
        logic: '#00ffcc',
        code: '#00ff88',
        pattern: '#ff00aa',
        memory: '#ffaa00',
        creative: '#aa00ff',
        sensory: '#ff4466',
        language: '#4488ff',
        weak: '#446688',
        flash: '#ffffcc',
        nodeCore: '#ffffff',
        nodePulse: '#aaeeff',
      };

      class ThoughtNode {
        constructor(x, y, z, w, v, category) {
          this.x = x;
          this.y = y;
          this.z = z;
          this.w = w;
          this.v = v;
          this.category = category;
          this.energy = 0.5 + Math.random() * 0.5;
          this.pulsePhase = Math.random() * Math.PI * 2;
          this.pulseSpeed = 0.03 + Math.random() * 0.04;
          this.size = 1.4 + Math.random() * 2.4;
          this.activation = 0.3 + Math.random() * 0.4;
          this.targetActivation = this.activation;
          this.vx = (Math.random() - 0.5) * 0.003;
          this.vy = (Math.random() - 0.5) * 0.003;
          this.vz = (Math.random() - 0.5) * 0.003;
          this.vw = (Math.random() - 0.5) * 0.002;
          this.vv = (Math.random() - 0.5) * 0.002;
          this.age = 0;
          this.maxAge = 520 + Math.random() * 680;
          this.life = 1;
        }

        update() {
          this.age++;
          this.pulsePhase += this.pulseSpeed;

          this.x += this.vx;
          this.y += this.vy;
          this.z += this.vz;
          this.w += this.vw;
          this.v += this.vv;

          const bound = 2.2;
          if (Math.abs(this.x) > bound) this.vx -= this.x * 0.002;
          if (Math.abs(this.y) > bound) this.vy -= this.y * 0.002;
          if (Math.abs(this.z) > bound) this.vz -= this.z * 0.002;
          if (Math.abs(this.w) > bound) this.vw -= this.w * 0.001;
          if (Math.abs(this.v) > bound) this.vv -= this.v * 0.001;

          this.activation += (this.targetActivation - this.activation) * 0.08;
          this.targetActivation *= 0.992;
          this.targetActivation = Math.max(0.2, this.targetActivation);

          if (this.age > this.maxAge) this.life -= 0.01;

          return this.life > 0;
        }

        activate(amount = 0.5) {
          this.targetActivation = Math.min(1, this.targetActivation + amount);
        }

        getColor() {
          const colors = {
            logic: COLORS.logic,
            code: COLORS.code,
            pattern: COLORS.pattern,
            memory: COLORS.memory,
            creative: COLORS.creative,
            sensory: COLORS.sensory,
            language: COLORS.language,
          };
          return colors[this.category] || COLORS.logic;
        }
      }

      class Connection {
        constructor(nodeA, nodeB, strength = 0.5) {
          this.nodeA = nodeA;
          this.nodeB = nodeB;
          this.strength = strength;
          this.activity = 0;
          this.pulsePosition = Math.random();
          this.pulseSpeed = 0.015 + Math.random() * 0.025;
          this.pulseDirection = Math.random() > 0.5 ? 1 : -1;
        }

        update() {
          this.pulsePosition += this.pulseSpeed * this.pulseDirection;
          if (this.pulsePosition > 1) { this.pulsePosition = 1; this.pulseDirection = -1; }
          if (this.pulsePosition < 0) { this.pulsePosition = 0; this.pulseDirection = 1; }
          this.activity = (this.nodeA.activation + this.nodeB.activation) * 0.5 * this.strength;
        }
      }

      class TokenStream {
        constructor() {
          this.tokens = [];
          this.baseY = (Math.random() - 0.5) * 1.8;
          this.baseZ = (Math.random() - 0.5) * 1.8;
          this.speed = 0.012 + Math.random() * 0.018;
          this.hue = 190 + Math.random() * 35;
          this.life = 1;
          this.maxTokens = 12 + Math.floor(Math.random() * 15);

          for (let i = 0; i < this.maxTokens; i++) {
            this.tokens.push({
              x: -2.5 + (i / this.maxTokens) * 5,
              y: this.baseY + (Math.random() - 0.5) * 0.3,
              z: this.baseZ + (Math.random() - 0.5) * 0.3,
              size: 0.4 + Math.random() * 0.5,
              alpha: 0.4 + Math.random() * 0.5,
            });
          }
        }

        update() {
          this.tokens.forEach((token, i) => {
            token.x += this.speed;
            if (token.x > 3) {
              token.x = -3;
              token.y = this.baseY + (Math.random() - 0.5) * 0.3;
            }
            token.y += Math.sin(token.x * 2 + i * 0.5) * 0.002;
          });
          this.life -= 0.0004;
          return this.life > 0;
        }
      }

      const project5Dto2D = (x, y, z, w, v, time) => {
        const a1 = time * 0.00025;
        const a2 = time * 0.0002;
        const a3 = time * 0.0003;

        const x1 = x * Math.cos(a1) - w * Math.sin(a1);
        const w1 = x * Math.sin(a1) + w * Math.cos(a1);

        const y1 = y * Math.cos(a2) - v * Math.sin(a2);
        const v1 = y * Math.sin(a2) + v * Math.cos(a2);

        const z1 = z * Math.cos(a3) - w1 * Math.sin(a3);
        const w2 = z * Math.sin(a3) + w1 * Math.cos(a3);

        const perspective = 3;
        const scale4 = perspective / Math.max(0.5, perspective - w2 * 0.5);
        const scale5 = perspective / Math.max(0.5, perspective - v1 * 0.5);
        const finalScale = scale4 * scale5;

        return {
          x: x1 * finalScale,
          y: y1 * finalScale,
          z: z1,
          scale: Math.max(0.3, Math.min(finalScale, 3)),
        };
      };

      const categories = ['logic', 'code', 'pattern', 'memory', 'creative', 'sensory', 'language'];
      const baseNodeCount = window.innerWidth > 1200 ? 70 : window.innerWidth > 900 ? 60 : 48;
      const maxNodes = 96;
      let nodes = [];
      let connections = [];
      let tokenStreams = [];
      let lastSpawnTime = 0;
      let frameCount = 0;

      for (let i = 0; i < baseNodeCount; i++) {
        nodes.push(new ThoughtNode(
          (Math.random() - 0.5) * 3.5,
          (Math.random() - 0.5) * 3.5,
          (Math.random() - 0.5) * 3.5,
          (Math.random() - 0.5) * 2.5,
          (Math.random() - 0.5) * 2.5,
          categories[Math.floor(Math.random() * categories.length)]
        ));
      }

      const rebuildConnections = () => {
        connections = [];
        for (let i = 0; i < nodes.length; i++) {
          for (let j = i + 1; j < nodes.length; j++) {
            const dx = nodes[i].x - nodes[j].x;
            const dy = nodes[i].y - nodes[j].y;
            const dz = nodes[i].z - nodes[j].z;
            const dw = nodes[i].w - nodes[j].w;
            const dv = nodes[i].v - nodes[j].v;
            const dist = Math.sqrt(dx * dx + dy * dy + dz * dz + dw * dw * 0.5 + dv * dv * 0.5);

            if (dist < 1.8) {
              connections.push(new Connection(nodes[i], nodes[j], 1 - dist / 1.8));
            } else if (nodes[i].category === nodes[j].category && Math.random() < 0.12) {
              connections.push(new Connection(nodes[i], nodes[j], 0.3));
            } else if (Math.random() < 0.008) {
              connections.push(new Connection(nodes[i], nodes[j], 0.2));
            }
          }
        }
      };

      rebuildConnections();

      const initialStreams = window.innerWidth > 900 ? 4 : 3;
      for (let i = 0; i < initialStreams; i++) {
        tokenStreams.push(new TokenStream());
      }

      let width, height, centerX, centerY, scale;

      const resize = () => {
        const dpr = window.devicePixelRatio || 1;
        width = window.innerWidth;
        height = window.innerHeight;
        canvas.width = width * dpr;
        canvas.height = height * dpr;
        canvas.style.width = width + 'px';
        canvas.style.height = height + 'px';
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
        centerX = width / 2;
        centerY = height / 2;
        scale = Math.min(width, height) * 0.25;
      };

      resize();
      window.addEventListener('resize', resize, { passive: true });

      const startTime = performance.now();

      const hexAlpha = (a) => Math.floor(Math.min(1, Math.max(0, a)) * 255).toString(16).padStart(2, '0');

      const animate = (time) => {
        const currentTime = time - startTime;
        frameCount++;

        ctx.fillStyle = COLORS.void;
        ctx.fillRect(0, 0, width, height);

        nodes = nodes.filter(node => node.update());
        if (nodes.length === 0) {
          nodes.push(new ThoughtNode(0, 0, 0, 0, 0, categories[Math.floor(Math.random() * categories.length)]));
        }

        connections = connections.filter(conn => conn.nodeA.life > 0 && conn.nodeB.life > 0);

        if (currentTime - lastSpawnTime > 420 && nodes.length < maxNodes) {
          const parent = nodes[Math.floor(Math.random() * nodes.length)];
          const child = new ThoughtNode(
            parent.x + (Math.random() - 0.5) * 0.8,
            parent.y + (Math.random() - 0.5) * 0.8,
            parent.z + (Math.random() - 0.5) * 0.8,
            parent.w + (Math.random() - 0.5) * 0.5,
            parent.v + (Math.random() - 0.5) * 0.5,
            Math.random() < 0.6 ? parent.category : categories[Math.floor(Math.random() * categories.length)]
          );
          nodes.push(child);
          parent.activate(0.5);
          child.activate(0.7);
          lastSpawnTime = currentTime;
        }

        if (frameCount % 120 === 0) {
          rebuildConnections();
        }

        connections.forEach(conn => conn.update());

        tokenStreams = tokenStreams.filter(s => s.update());
        if (tokenStreams.length < 6 && Math.random() < 0.015) {
          tokenStreams.push(new TokenStream());
        }

        if (Math.random() < 0.02 && nodes.length > 0) {
          const burstNode = nodes[Math.floor(Math.random() * nodes.length)];
          burstNode.activate(0.8);
          nodes.forEach(n => {
            const dx = n.x - burstNode.x;
            const dy = n.y - burstNode.y;
            const dz = n.z - burstNode.z;
            const dist = Math.sqrt(dx * dx + dy * dy + dz * dz);
            if (dist < 1 && n !== burstNode) {
              n.activate(0.4 * (1 - dist));
            }
          });
        }

        tokenStreams.forEach(stream => {
          stream.tokens.forEach(token => {
            const proj = project5Dto2D(token.x, token.y, token.z, 0, 0, currentTime);
            const sx = centerX + proj.x * scale;
            const sy = centerY + proj.y * scale;
            const sz = token.size * proj.scale * 12;
            const alpha = token.alpha * stream.life * proj.scale * 0.7;

            if (sx > -50 && sx < width + 50 && sy > -50 && sy < height + 50) {
              const gradient = ctx.createRadialGradient(sx, sy, 0, sx, sy, sz);
              gradient.addColorStop(0, `hsla(${stream.hue}, 80%, 70%, ${alpha})`);
              gradient.addColorStop(0.4, `hsla(${stream.hue}, 70%, 50%, ${alpha * 0.4})`);
              gradient.addColorStop(1, 'transparent');
              ctx.fillStyle = gradient;
              ctx.beginPath();
              ctx.arc(sx, sy, sz, 0, Math.PI * 2);
              ctx.fill();
            }
          });
        });

        ctx.lineCap = 'round';
        connections.forEach(conn => {
          const projA = project5Dto2D(conn.nodeA.x, conn.nodeA.y, conn.nodeA.z, conn.nodeA.w, conn.nodeA.v, currentTime);
          const projB = project5Dto2D(conn.nodeB.x, conn.nodeB.y, conn.nodeB.z, conn.nodeB.w, conn.nodeB.v, currentTime);

          const ax = centerX + projA.x * scale;
          const ay = centerY + projA.y * scale;
          const bx = centerX + projB.x * scale;
          const by = centerY + projB.y * scale;

          const alpha = (conn.strength * 0.3 + conn.activity * 0.5) * conn.nodeA.life * conn.nodeB.life;
          if (alpha < 0.02) return;

          const gradient = ctx.createLinearGradient(ax, ay, bx, by);
          gradient.addColorStop(0, conn.nodeA.getColor() + hexAlpha(alpha * 0.7));
          gradient.addColorStop(0.5, COLORS.weak + hexAlpha(alpha * 0.9));
          gradient.addColorStop(1, conn.nodeB.getColor() + hexAlpha(alpha * 0.7));

          ctx.strokeStyle = gradient;
          ctx.lineWidth = 0.8 + conn.activity * 3 + conn.strength * 0.8;
          ctx.beginPath();
          ctx.moveTo(ax, ay);
          ctx.lineTo(bx, by);
          ctx.stroke();

          if (conn.activity > 0.12) {
            const px = ax + (bx - ax) * conn.pulsePosition;
            const py = ay + (by - ay) * conn.pulsePosition;
            const pulseSize = 6 + conn.activity * 12;
            const pulseGradient = ctx.createRadialGradient(px, py, 0, px, py, pulseSize);
            pulseGradient.addColorStop(0, COLORS.flash + hexAlpha(conn.activity * 0.9));
            pulseGradient.addColorStop(0.5, COLORS.flash + hexAlpha(conn.activity * 0.4));
            pulseGradient.addColorStop(1, 'transparent');
            ctx.fillStyle = pulseGradient;
            ctx.beginPath();
            ctx.arc(px, py, pulseSize, 0, Math.PI * 2);
            ctx.fill();
          }
        });

        nodes.forEach(node => {
          const proj = project5Dto2D(node.x, node.y, node.z, node.w, node.v, currentTime);
          const sx = centerX + proj.x * scale;
          const sy = centerY + proj.y * scale;

          if (sx < -100 || sx > width + 100 || sy < -100 || sy > height + 100) return;

          const pulse = Math.sin(node.pulsePhase) * 0.25 + 0.75;
          const baseSize = node.size * proj.scale * 8;
          const size = baseSize * (1 + node.activation * 0.4);
          const alpha = (node.energy * 0.4 + node.activation * 0.6) * pulse * node.life;

          const outerGradient = ctx.createRadialGradient(sx, sy, 0, sx, sy, size * 4);
          outerGradient.addColorStop(0, node.getColor() + hexAlpha(alpha * 0.7));
          outerGradient.addColorStop(0.3, node.getColor() + hexAlpha(alpha * 0.35));
          outerGradient.addColorStop(0.6, node.getColor() + hexAlpha(alpha * 0.1));
          outerGradient.addColorStop(1, 'transparent');
          ctx.fillStyle = outerGradient;
          ctx.beginPath();
          ctx.arc(sx, sy, size * 4, 0, Math.PI * 2);
          ctx.fill();

          if (node.activation > 0.3) {
            const innerGradient = ctx.createRadialGradient(sx, sy, 0, sx, sy, size * 2);
            innerGradient.addColorStop(0, COLORS.nodePulse + hexAlpha(node.activation * 0.6));
            innerGradient.addColorStop(0.5, COLORS.nodePulse + hexAlpha(node.activation * 0.2));
            innerGradient.addColorStop(1, 'transparent');
            ctx.fillStyle = innerGradient;
            ctx.beginPath();
            ctx.arc(sx, sy, size * 2, 0, Math.PI * 2);
            ctx.fill();
          }

          ctx.fillStyle = COLORS.nodeCore + hexAlpha(alpha * 0.95);
          ctx.beginPath();
          ctx.arc(sx, sy, size * 0.35, 0, Math.PI * 2);
          ctx.fill();
        });

        const vignetteGradient = ctx.createRadialGradient(
          centerX, centerY, Math.min(width, height) * 0.15,
          centerX, centerY, Math.max(width, height) * 0.7
        );
        vignetteGradient.addColorStop(0, 'transparent');
        vignetteGradient.addColorStop(0.5, 'transparent');
        vignetteGradient.addColorStop(1, 'rgba(3, 3, 8, 0.75)');
        ctx.fillStyle = vignetteGradient;
        ctx.fillRect(0, 0, width, height);

        requestAnimationFrame(animate);
      };

      requestAnimationFrame(animate);
    })();
  </script>
</body>

</html>
